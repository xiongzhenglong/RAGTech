# 探索已解析的 PDF 数据：Python 脚本 `demo_02_exploring_parsed_pdf.py` 详解

大家好！在上一篇教程中，我们可能已经了解了如何使用 Python 解析 PDF 文件（例如通过 `demo_01_pdf_parsing.py`）。PDF 解析完成后，通常会得到一个结构化的数据输出，常见的是 JSON 格式。这个 JSON 文件就像一张藏宝图，包含了从 PDF 中提取出的所有信息：文本、表格、图片、元数据等等。

本篇教程将详细解读一个 Python 脚本 `study/demo_02_exploring_parsed_pdf.py`。这个脚本的目的是向我们展示如何加载并“探索”这个由 PDF 解析器生成的 JSON 文件，从而理解其内部结构，并提取出我们感兴趣的数据片段。

## 脚本目标

- 加载一个预先存在的、由 PDF 解析过程生成的 JSON 文件。
- 演示如何访问和提取 JSON 文件中不同部分的数据，例如：
    - 文档的元信息（metainfo）
    - 特定页面的文本内容
    - 文档中表格的详细信息
    - 文档中图片的详细信息
- 处理可能发生的错误，如文件未找到或 JSON 格式无效。

## 前提条件

- 你已经有一个由 PDF 解析器生成的 JSON 文件。在本示例中，脚本期望这个文件位于 `study/parsed_output/` 目录下，并命名为 `194000c9109c6fa628f1fed33b44ae4c2b8365f4.json`。这个文件可能是运行类似 `demo_01_pdf_parsing.py` 脚本后的产物。
- 你已安装 Python，并且了解基本的 Python 语法。

## Python 脚本 `demo_02_exploring_parsed_pdf.py`

首先，让我们完整地看一下这个脚本的代码：

```python
# study/demo_02_exploring_parsed_pdf.py

import json
import os

def main():
    """
    Explores the structure of a parsed PDF JSON output from PDFParser.
    It demonstrates how to access various parts of the document,
    such as metadata, page content, tables, and pictures.
    """
    print("Starting exploration of parsed PDF JSON data...")

    # --- 1. Define Input JSON Path ---
    # This is the path to the JSON file generated by demo_01_pdf_parsing.py.
    # It assumes the output of the previous demo script is available.
    input_json_filename = "194000c9109c6fa628f1fed33b44ae4c2b8365f4.json"
    input_json_path = os.path.join("study", "parsed_output", input_json_filename)
    print(f"Attempting to load parsed data from: {input_json_path}")

    # --- 2. Load JSON Data ---
    if not os.path.exists(input_json_path):
        print(f"Error: Parsed JSON file not found at {input_json_path}")
        print("Please ensure you have run 'demo_01_pdf_parsing.py' successfully,")
        print("and the output file is in the 'study/parsed_output/' directory.")
        return

    try:
        with open(input_json_path, 'r', encoding='utf-8') as f:
            parsed_data = json.load(f)
        print("Successfully loaded parsed JSON data.")
    except json.JSONDecodeError:
        print(f"Error: Could not decode the JSON file at {input_json_path}.")
        print("The file might be corrupted or not a valid JSON.")
        return
    except Exception as e:
        print(f"An error occurred while loading the JSON file: {e}")
        return

    # --- 3. Explore and Print Sections ---

    # --- 3.1. Metainfo ---
    # The 'metainfo' section typically contains document-level metadata.
    # This can include the document's SHA256 hash, filename, number of pages,
    # and other general information extracted during parsing.
    print("\n--- Document Metainfo ---")
    if 'metainfo' in parsed_data and parsed_data['metainfo']:
        for key, value in parsed_data['metainfo'].items():
            print(f"  {key}: {value}")
    else:
        print("  No 'metainfo' section found or it is empty.")
    print("-------------------------")

    # --- 3.2. Content of the First Page ---
    # The 'content' key in the JSON usually holds a list of page objects.
    # Each page object contains its page number and a list of its content elements
    # (e.g., text blocks, paragraphs, headers, footers).
    # The actual text is often nested within these content elements.
    print("\n--- Content of First Page (First 500 Chars) ---")
    if 'content' in parsed_data and parsed_data['content']:
        first_page_data = parsed_data['content'][0] # Assuming 'content' is a list of pages
        page_number = first_page_data.get('page', 'N/A') # 'page' attribute stores the page number
        print(f"  Page Number: {page_number}")

        page_text_segments = []
        # The content of a page is typically a list of blocks (e.g., paragraphs, headers).
        # Each block itself might have a 'content' list containing text spans or lines.
        if 'content' in first_page_data and first_page_data['content']:
            for block in first_page_data['content']:
                # Blocks can be of various types (e.g., 'TextBlock', 'Paragraph').
                # We are interested in the textual content.
                # Some parsers might store text directly in block['text'],
                # others might have a nested 'content' list with text spans.
                if 'text' in block and block['text']:
                    page_text_segments.append(str(block['text']))
                elif 'content' in block and block['content']: # For nested content like text spans
                    for sub_element in block['content']:
                        if 'text' in sub_element and sub_element['text']:
                             page_text_segments.append(str(sub_element['text']))

        if page_text_segments:
            full_page_text = " ".join(page_text_segments)
            print(f"  Combined Text (Snippet):\n\"{full_page_text[:500]}...\"")
        else:
            print("  No textual content found or structure is different than expected for the first page.")
    else:
        print("  No 'content' section found, or it does not contain page data.")
    print("---------------------------------------------")

    # --- 3.3. Details of the First Table ---
    # The 'tables' section usually contains a list of all tables detected in the document.
    # Each table object provides its ID, page number, bounding box, number of rows/columns,
    # and often a Markdown or HTML representation of the table's content.
    print("\n--- Details of the First Table ---")
    if 'tables' in parsed_data and parsed_data['tables']:
        first_table_data = parsed_data['tables'][0]
        table_id = first_table_data.get('table_id', 'N/A')
        table_page = first_table_data.get('page', 'N/A')
        num_rows = first_table_data.get('rows', 'N/A')
        num_cols = first_table_data.get('columns', 'N/A') # Note: key might be 'cols' or 'columns'
        if 'columns' not in first_table_data and 'cols' in first_table_data:
            num_cols = first_table_data.get('cols')


        print(f"  Table ID: {table_id}")
        print(f"  Page: {table_page}")
        print(f"  Dimensions: {num_rows} rows x {num_cols} columns")

        # The 'markdown' representation is a text-based format of the table.
        markdown_repr = first_table_data.get('markdown', 'N/A')
        print(f"  Markdown Representation (Snippet):\n{markdown_repr[:300]}...")
    else:
        print("  No tables found in the document.")
    print("----------------------------------")

    # --- 3.4. Details of the First Picture ---
    # The 'pictures' section (sometimes 'figures' or 'images') contains a list of
    # image-like elements detected in the document.
    # Each picture object includes its ID, page number, and bounding box (bbox).
    # The bbox defines the picture's location and size on the page.
    print("\n--- Details of the First Picture ---")
    if 'pictures' in parsed_data and parsed_data['pictures']:
        first_picture_data = parsed_data['pictures'][0]
        picture_id = first_picture_data.get('picture_id', 'N/A') # Or 'id', 'figure_id'
        picture_page = first_picture_data.get('page', 'N/A')
        bbox = first_picture_data.get('bbox', 'N/A') # Bounding box [x_min, y_min, x_max, y_max]

        print(f"  Picture ID: {picture_id}")
        print(f"  Page: {picture_page}")
        print(f"  Bounding Box (bbox): {bbox}")
    else:
        print("  No pictures found in the document.")
    print("------------------------------------")

    print("\nExploration complete.")

if __name__ == "__main__":
    main()
```

## 脚本代码详解

### 1. 导入模块

```python
import json
import os
```
- `json`: 这是 Python 的标准库，用于处理 JSON 数据。我们将用它来加载（`json.load()`）和解析 JSON 文件。
- `os`: 这个标准库提供了与操作系统交互的功能，例如构建文件路径（`os.path.join()`）和检查文件是否存在（`os.path.exists()`）。

### 2. `main()` 函数

这是脚本的主体部分。

#### 2.1. 定义输入 JSON 文件路径

```python
    input_json_filename = "194000c9109c6fa628f1fed33b44ae4c2b8365f4.json"
    input_json_path = os.path.join("study", "parsed_output", input_json_filename)
    print(f"Attempting to load parsed data from: {input_json_path}")
```
- `input_json_filename`: 存储了目标 JSON 文件的名称。
- `os.path.join("study", "parsed_output", input_json_filename)`: 这行代码非常实用。它会根据你的操作系统智能地将各个部分连接成一个完整的文件路径（例如，在 Linux/macOS 上是 `study/parsed_output/your_file.json`，在 Windows 上是 `study\parsed_output\your_file.json`）。这比手动拼接字符串更安全、更通用。
- 脚本会打印出它将尝试加载的文件的完整路径。

#### 2.2. 加载 JSON 数据

```python
    if not os.path.exists(input_json_path):
        print(f"Error: Parsed JSON file not found at {input_json_path}")
        # ... (错误提示) ...
        return

    try:
        with open(input_json_path, 'r', encoding='utf-8') as f:
            parsed_data = json.load(f)
        print("Successfully loaded parsed JSON data.")
    except json.JSONDecodeError:
        print(f"Error: Could not decode the JSON file at {input_json_path}.")
        # ... (错误提示) ...
        return
    except Exception as e:
        print(f"An error occurred while loading the JSON file: {e}")
        return
```
- **文件存在性检查**: `os.path.exists(input_json_path)` 首先检查指定路径的 JSON 文件是否存在。如果不存在，脚本会打印错误信息并退出。
- **打开和加载 JSON**:
    - `with open(input_json_path, 'r', encoding='utf-8') as f:`: 这是一种推荐的文件操作方式。
        - `input_json_path`: 要打开的文件。
        - `'r'`: 以只读模式打开。
        - `encoding='utf-8'`: 指定使用 UTF-8 编码打开文件。UTF-8 是一种通用的字符编码，能很好地处理各种语言的文本，对于包含多种字符的 JSON 文件来说是个好选择。
        - `as f`: 将打开的文件对象赋值给变量 `f`。
        - `with` 语句能确保文件在使用完毕后自动关闭，即使发生错误也是如此。
    - `parsed_data = json.load(f)`: 这是关键的一步。`json.load()` 函数读取打开的文件对象 `f`，并将其中的 JSON 数据转换成 Python 的数据结构（通常是字典和列表的嵌套组合）。
- **错误处理**:
    - `json.JSONDecodeError`: 如果文件内容不是有效的 JSON 格式（例如，文件损坏、语法错误），`json.load()` 会抛出此异常。脚本会捕获它并打印相应的错误信息。
    - `Exception as e`: 这是一个更通用的异常捕获，用于处理其他可能的文件加载错误（例如权限问题）。

#### 2.3. 探索和打印不同部分 (`parsed_data`)

一旦 JSON 数据成功加载到 `parsed_data` 变量中，脚本就开始探索其内部结构。通常，PDF 解析器生成的 JSON 会有一个顶层结构，包含文档的各个方面。

##### 2.3.1. 文档元信息 (`metainfo`)

```python
    print("\n--- Document Metainfo ---")
    if 'metainfo' in parsed_data and parsed_data['metainfo']:
        for key, value in parsed_data['metainfo'].items():
            print(f"  {key}: {value}")
    else:
        print("  No 'metainfo' section found or it is empty.")
    print("-------------------------")
```
- **检查是否存在**: `if 'metainfo' in parsed_data and parsed_data['metainfo']:`
    - 首先检查 `parsed_data` 字典中是否有 `'metainfo'` 这个键。
    - 然后检查 `parsed_data['metainfo']` 是否不为空（有些解析器可能在没有元信息时返回一个空的字典或列表）。
- **遍历和打印**: 如果存在且不为空，脚本会遍历 `'metainfo'` 字典中的每一个键值对 (`key, value`) 并打印出来。
- **常见的元信息**: 这部分可能包含文件名、文档的 SHA256 哈希值（用于校验文件完整性）、总页数、文档标题、作者等。具体内容取决于解析器的实现。

##### 2.3.2. 第一页的内容

```python
    print("\n--- Content of First Page (First 500 Chars) ---")
    if 'content' in parsed_data and parsed_data['content']:
        first_page_data = parsed_data['content'][0] # 假设 'content' 是页面列表
        page_number = first_page_data.get('page', 'N/A')
        print(f"  Page Number: {page_number}")

        page_text_segments = []
        if 'content' in first_page_data and first_page_data['content']:
            for block in first_page_data['content']: # 遍历页面内的块
                if 'text' in block and block['text']:
                    page_text_segments.append(str(block['text']))
                elif 'content' in block and block['content']: # 块内可能还有嵌套内容
                    for sub_element in block['content']:
                        if 'text' in sub_element and sub_element['text']:
                             page_text_segments.append(str(sub_element['text']))
        
        if page_text_segments:
            full_page_text = " ".join(page_text_segments)
            print(f"  Combined Text (Snippet):\n\"{full_page_text[:500]}...\"")
        # ... (其他处理) ...
    # ... (其他处理) ...
    print("---------------------------------------------")
```
- **访问页面数据**:
    - 脚本假设顶层 JSON 的 `'content'` 键对应一个列表，列表中的每个元素代表一个页面。
    - `first_page_data = parsed_data['content'][0]` 获取列表中的第一个元素，即第一页的数据。
    - `page_number = first_page_data.get('page', 'N/A')` 尝试获取该页的页码。`.get('page', 'N/A')` 是一种安全的字典访问方式，如果 `'page'` 键不存在，它会返回 `'N/A'` 而不是抛出 `KeyError`。
- **提取文本**:
    - 页面内容 (`first_page_data['content']`) 本身通常也是一个列表，包含页面上的各种元素或“块”（如段落、标题、列表项）。
    - 脚本遍历这些块：
        - 它首先检查块本身是否有 `'text'` 属性并直接提取。
        - 如果没有，它会检查块是否有一个嵌套的 `'content'` 列表（例如，一个段落块可能包含多个具有不同格式的文本片段/span）。如果存在，它会再次遍历这些子元素以提取文本。
    - `page_text_segments.append(str(block['text']))`: 将提取到的文本片段（转换为字符串以防是其他类型）添加到一个列表中。
    - `full_page_text = " ".join(page_text_segments)`: 将所有文本片段用空格连接起来，形成该页的完整文本。
    - `print(f"  Combined Text (Snippet):\n\"{full_page_text[:500]}...\"")`: 打印提取到的文本的前 500 个字符作为片段预览。
- **结构多样性**: PDF 内容结构可能非常复杂。这里的代码演示了一种常见的嵌套结构。实际的 JSON 结构会因 PDF 解析器的不同而有所差异。你需要根据你使用的解析器输出的实际 JSON 格式来调整这部分代码。

##### 2.3.3. 第一个表格的详细信息

```python
    print("\n--- Details of the First Table ---")
    if 'tables' in parsed_data and parsed_data['tables']:
        first_table_data = parsed_data['tables'][0] # 获取第一个表格
        table_id = first_table_data.get('table_id', 'N/A')
        table_page = first_table_data.get('page', 'N/A')
        num_rows = first_table_data.get('rows', 'N/A')
        num_cols = first_table_data.get('columns', 'N/A')
        if 'columns' not in first_table_data and 'cols' in first_table_data: # 兼容不同的键名
            num_cols = first_table_data.get('cols')

        print(f"  Table ID: {table_id}")
        print(f"  Page: {table_page}")
        print(f"  Dimensions: {num_rows} rows x {num_cols} columns")

        markdown_repr = first_table_data.get('markdown', 'N/A')
        print(f"  Markdown Representation (Snippet):\n{markdown_repr[:300]}...")
    # ... (其他处理) ...
    print("----------------------------------")
```
- **访问表格数据**:
    - 脚本假设顶层 JSON 有一个 `'tables'` 键，对应一个列表，其中包含了文档中所有检测到的表格。
    - `first_table_data = parsed_data['tables'][0]` 获取第一个表格的数据。
- **提取表格信息**:
    - `table_id`, `page` (表格所在的页码), `rows` (行数), `columns` (列数) 等都是表格对象中常见的属性。
    - **键名兼容性**: 注意到 `if 'columns' not in first_table_data and 'cols' in first_table_data:` 这一行，它尝试兼容不同的解析器可能使用的列数键名（`'columns'` 或 `'cols'`）。
    - `markdown_repr = first_table_data.get('markdown', 'N/A')`: 许多 PDF 解析工具会将表格内容转换为 Markdown 或 HTML 格式，方便查看或进一步处理。脚本尝试获取 Markdown 表示，并打印其前 300 个字符。
- **其他表格属性**: 表格对象还可能包含每个单元格的内容、表头信息、表格在页面上的边界框（bounding box）等。

##### 2.3.4. 第一个图片的详细信息

```python
    print("\n--- Details of the First Picture ---")
    if 'pictures' in parsed_data and parsed_data['pictures']: # 也可能是 'figures' 或 'images'
        first_picture_data = parsed_data['pictures'][0]
        picture_id = first_picture_data.get('picture_id', 'N/A') # 或 'id', 'figure_id'
        picture_page = first_picture_data.get('page', 'N/A')
        bbox = first_picture_data.get('bbox', 'N/A') # 边界框

        print(f"  Picture ID: {picture_id}")
        print(f"  Page: {picture_page}")
        print(f"  Bounding Box (bbox): {bbox}")
    # ... (其他处理) ...
    print("------------------------------------")
```
- **访问图片数据**:
    - 脚本假设顶层 JSON 有一个 `'pictures'` 键（注释中提到也可能是 `'figures'` 或 `'images'`，具体取决于解析器）。
    - `first_picture_data = parsed_data['pictures'][0]` 获取第一个图片的信息。
- **提取图片信息**:
    - `picture_id` (图片/图表的唯一标识), `page` (图片所在的页码)。
    - `bbox` (bounding box): 这是一个非常重要的属性，通常是一个包含四个数字的列表 `[x_min, y_min, x_max, y_max]`，定义了图片在页面上的位置和大小（左上角 x,y 坐标和右下角 x,y 坐标）。
- **图片内容**: 这个 JSON 通常只包含图片的元数据和位置信息，而不是图片本身的像素数据。图片数据可能被单独提取并存储为图像文件。

### 3. 脚本入口

```python
if __name__ == "__main__":
    main()
```
- 这是 Python 脚本的标准入口点。当直接运行此脚本时，`main()` 函数会被调用。

## 预期的 JSON 结构（概念性）

虽然不同 PDF 解析工具输出的 JSON 结构会有所不同，但它们通常都具有一定的层级关系。理解这种层级关系对于解析 JSON 至关重要。一个典型的（高度简化的）概念结构可能如下：

```json
{
  "metainfo": {
    "filename": "example.pdf",
    "num_pages": 2,
    "sha256": "..."
  },
  "content": [ // 页面列表
    { // 第一页
      "page": 1,
      "content": [ // 页面内的内容块列表
        {
          "type": "Paragraph", // 或 TextBlock
          "text": "这是第一段的文本。",
          "bbox": [x1, y1, x2, y2]
        },
        {
          "type": "Header",
          "level": 1,
          "text": "这是一个一级标题",
          "bbox": [...]
        }
        // ...更多内容块
      ]
    },
    { // 第二页
      "page": 2,
      "content": [ /* ... */ ]
    }
  ],
  "tables": [ // 文档中所有表格的列表
    {
      "table_id": "table_001",
      "page": 1,
      "rows": 5,
      "columns": 3,
      "bbox": [...],
      "markdown": "| Header 1 | Header 2 | Header 3 |\n|---|---|---|\n| Cell 1 | Cell 2 | Cell 3 | ...",
      "cells": [ // 更详细的单元格数据
        // ...
      ]
    }
  ],
  "pictures": [ // 文档中所有图片的列表
    {
      "picture_id": "pic_001",
      "page": 2,
      "bbox": [x_min, y_min, x_max, y_max],
      "caption": "图1：一个示例图片" // 可选
    }
  ]
  // 可能还有其他部分，如 "figures", "charts", "list_items" 等
}
```
**关键点**：
- **根对象**: 整个 JSON 是一个大的字典（对象）。
- **键值对**: 信息以键值对的形式存储。
- **嵌套**: 页面 (`content`) 包含内容块，内容块又可能包含文本片段。
- **列表**: 页面、表格、图片通常以列表的形式组织，即使只有一个元素。
- **ID 和引用**: 有时，元素（如表格、图片）会有 ID，文本内容中可能会引用这些 ID。

## 如何运行脚本

1.  **准备 JSON 文件**: 确保你有一个由 PDF 解析器生成的 JSON 文件，例如 `194000c9109c6fa628f1fed33b44ae4c2b8365f4.json`，并将其放置在 `study/parsed_output/` 目录下（如果目录不存在，请创建它）。
2.  **打开终端或命令行工具**。
3.  **导航到脚本所在的目录** (例如 `study/` 目录，或者包含 `study` 目录的项目根目录)。
4.  **执行脚本**:
    ```bash
    python study/demo_02_exploring_parsed_pdf.py
    ```
    或者，如果你在项目的根目录下：
    ```bash
    python -m study.demo_02_exploring_parsed_pdf
    ```
    脚本将运行并打印出从 JSON 文件中提取的各种信息片段。

## 总结

`demo_02_exploring_parsed_pdf.py` 脚本为我们提供了一个实用的起点，展示了如何加载和初步检查 PDF 解析器生成的 JSON 输出。通过理解 JSON 的结构并使用 Python 的 `json` 库，我们可以有效地提取文档的元数据、文本内容、表格和图片信息等。

对于初学者来说，最重要的一点是：**JSON 结构是关键**。在尝试提取特定数据之前，最好先打开 JSON 文件看一看它的实际结构，或者使用类似这样的脚本进行探索。一旦掌握了目标数据在 JSON 中的路径和格式，提取工作就会变得简单明了。

希望这篇教程能帮助你更好地理解和利用 PDF 解析后的数据！
